package checkpoint

import (
	"fmt"
	"log"
	"strconv"

	checkpoint "github.com/CheckPointSW/cp-mgmt-api-go-sdk/APIFiles"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceManagementServiceGtp() *schema.Resource {
	return &schema.Resource{
		Create: createManagementServiceGtp,
		Read:   readManagementServiceGtp,
		Update: updateManagementServiceGtp,
		Delete: deleteManagementServiceGtp,
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Object name.",
			},
			"version": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "GTP version.",
				Default:     "V2",
			},
			"access_point_name": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Match by Access Point Name.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
							Default:     false,
						},
						"apn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Access Point Name object identified by Name or UID.",
						},
					},
				},
			},
			"allow_usage_of_static_ip": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Allow usage of static IP addresses.",
				Default:     true,
			},
			"apply_access_policy_on_user_traffic": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Apply Access Policy on user traffic.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
							Default:     false,
						},
						"add_imsi_field_to_log": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "Add IMSI field to logs generated by user traffic.",
							Default:     false,
						},
					},
				},
			},
			"cs_fallback_and_srvcc": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "CS Fallback and SRVCC (Relevant for V2 only).",
				Default:     true,
			},
			"imsi_prefix": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Match by IMSI prefix.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
							Default:     false,
						},
						"prefix": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The IMSI prefix.",
						},
					},
				},
			},
			"interface_profile": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Match only message types relevant to the given GTP interface. Relevant only for GTP V1 or V2.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"profile": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Interface Profile object identified by Name or UID.",
							Default:     "Any",
						},
						"custom_message_types": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The messages types to match on them for this service. To specify a range, add a hyphen between the lowest and the highest numbers, for example: 32-35. Multiple Ranges can be chosen when separated with comma. This field relevant only when the Interface profile is set to 'Custom'.",
						},
					},
				},
			},
			"ldap_group": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Match by an LDAP Group.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
							Default:     false,
						},
						"group": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The Ldap Group object identified by Name or UID.",
						},
						"according_to": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "According to MS-ISDN or according to IMSI.",
							Default:     "MS-ISDN",
						},
					},
				},
			},
			"ms_isdn": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "Match by an MS-ISDN.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
							Default:     false,
						},
						"ms_isdn": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "The MS-ISDN.",
						},
					},
				},
			},
			"radio_access_technology": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Match by Radio Access Technology.",
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"utran": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(1).",
							Default:     false,
						},
						"geran": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(2).",
							Default:     false,
						},
						"wlan": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(3).",
							Default:     false,
						},
						"gan": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(4).",
							Default:     false,
						},
						"hspa_evolution": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(5).",
							Default:     false,
						},
						"eutran": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(6).",
							Default:     false,
						},
						"virtual": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(7).",
							Default:     false,
						},
						"nb_iot": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "(8).",
							Default:     false,
						},
						"other_types_range": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "(9-255).",
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enable": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: "",
										Default:     false,
									},
									"types": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Other RAT Types. To specify other RAT ranges, add a hyphen between the lowest and the highest numbers, for example: 11-15. Multiple Ranges can be chosen when separated with comma.",
									},
								},
							},
						},
					},
				},
			},
			"restoration_and_recovery": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Restoration and Recovery (Relevant for V2 only).",
				Default:     true,
			},
			"reverse_service": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Accept PDUs from the GGSN/PGW to the SGSN/SGW on a previously established PDP context, even if different ports are used.",
				Default:     false,
			},
			"selection_mode": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Match by a selection mode.",
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "",
							Default:     false,
						},
						"mode": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The mode as integer. [0 - Verified, 1 - MS - Not verified, 2 - Network - Not verified].",
						},
					},
				},
			},
			"trace_management": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Trace Management (Relevant for V2 only).",
				Default:     true,
			},
			"tags": {
				Type:        schema.TypeSet,
				Optional:    true,
				Description: "Collection of tag identifiers.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"color": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Color of the object. Should be one of existing colors.",
				Default:     "black",
			},
			"comments": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Comments string.",
			},
			"groups": {
				Type:        schema.TypeSet,
				Optional:    true,
				Description: "Collection of group identifiers.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"ignore_warnings": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Apply changes ignoring warnings.",
				Default:     false,
			},
			"ignore_errors": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: "Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.",
				Default:     false,
			},
		},
	}
}

func createManagementServiceGtp(d *schema.ResourceData, m interface{}) error {
	client := m.(*checkpoint.ApiClient)

	serviceGtp := make(map[string]interface{})

	if v, ok := d.GetOk("name"); ok {
		serviceGtp["name"] = v.(string)
	}

	if v, ok := d.GetOk("version"); ok {
		serviceGtp["version"] = v.(string)
	}

	if v, ok := d.GetOk("access_point_name"); ok {

		accessPointNameList := v.([]interface{})

		if len(accessPointNameList) > 0 {

			accessPointNamePayload := make(map[string]interface{})

			if v, ok := d.GetOk("access_point_name.0.enable"); ok {
				accessPointNamePayload["enable"] = v.(bool)
			}
			if v, ok := d.GetOk("access_point_name.0.apn"); ok {
				accessPointNamePayload["apn"] = v.(string)
			}
			serviceGtp["access-point-name"] = accessPointNamePayload
		}
	}

	if v, ok := d.GetOkExists("allow_usage_of_static_ip"); ok {
		serviceGtp["allow-usage-of-static-ip"] = v.(bool)
	}

	if v, ok := d.GetOk("apply_access_policy_on_user_traffic"); ok {

		applyAccessPolicyOnUserTrafficList := v.([]interface{})

		if len(applyAccessPolicyOnUserTrafficList) > 0 {

			applyAccessPolicyOnUserTrafficPayload := make(map[string]interface{})

			if v, ok := d.GetOk("apply_access_policy_on_user_traffic.0.enable"); ok {
				applyAccessPolicyOnUserTrafficPayload["enable"] = v.(bool)
			}
			if v, ok := d.GetOk("apply_access_policy_on_user_traffic.0.add_imsi_field_to_log"); ok {
				applyAccessPolicyOnUserTrafficPayload["add-imsi-field-to-log"] = v.(bool)
			}
			serviceGtp["apply-access-policy-on-user-traffic"] = applyAccessPolicyOnUserTrafficPayload
		}
	}

	if v, ok := d.GetOkExists("cs_fallback_and_srvcc"); ok {
		serviceGtp["cs-fallback-and-srvcc"] = v.(bool)
	}

	if v, ok := d.GetOk("imsi_prefix"); ok {

		imsiPrefixList := v.([]interface{})

		if len(imsiPrefixList) > 0 {

			imsiPrefixPayload := make(map[string]interface{})

			if v, ok := d.GetOk("imsi_prefix.0.enable"); ok {
				imsiPrefixPayload["enable"] = v.(bool)
			}
			if v, ok := d.GetOk("imsi_prefix.0.prefix"); ok {
				imsiPrefixPayload["prefix"] = v.(string)
			}
			serviceGtp["imsi-prefix"] = imsiPrefixPayload
		}
	}

	if v, ok := d.GetOk("interface_profile"); ok {

		interfaceProfileList := v.([]interface{})

		if len(interfaceProfileList) > 0 {

			interfaceProfilePayload := make(map[string]interface{})

			if v, ok := d.GetOk("interface_profile.0.profile"); ok {
				interfaceProfilePayload["profile"] = v.(string)
			}
			if v, ok := d.GetOk("interface_profile.0.custom_message_types"); ok {
				interfaceProfilePayload["custom-message-types"] = v.(string)
			}
			serviceGtp["interface-profile"] = interfaceProfilePayload
		}
	}

	if v, ok := d.GetOk("ldap_group"); ok {

		ldapGroupList := v.([]interface{})

		if len(ldapGroupList) > 0 {

			ldapGroupPayload := make(map[string]interface{})

			if v, ok := d.GetOk("ldap_group.0.enable"); ok {
				ldapGroupPayload["enable"] = v.(bool)
			}
			if v, ok := d.GetOk("ldap_group.0.group"); ok {
				ldapGroupPayload["group"] = v.(string)
			}
			if v, ok := d.GetOk("ldap_group.0.according_to"); ok {
				ldapGroupPayload["according-to"] = v.(string)
			}
			serviceGtp["ldap-group"] = ldapGroupPayload
		}
	}

	if v, ok := d.GetOk("ms_isdn"); ok {

		msIsdnList := v.([]interface{})

		if len(msIsdnList) > 0 {

			msIsdnPayload := make(map[string]interface{})

			if v, ok := d.GetOk("ms_isdn.0.enable"); ok {
				msIsdnPayload["enable"] = v.(bool)
			}
			if v, ok := d.GetOk("ms_isdn.0.ms_isdn"); ok {
				msIsdnPayload["ms-isdn"] = v.(string)
			}
			serviceGtp["ms-isdn"] = msIsdnPayload
		}
	}

	if v, ok := d.GetOk("radio_access_technology"); ok {

		radioAccessTechnologyList := v.([]interface{})

		if len(radioAccessTechnologyList) > 0 {

			radioAccessTechnologyPayload := make(map[string]interface{})

			if v, ok := d.GetOk("radio_access_technology.0.utran"); ok {
				radioAccessTechnologyPayload["utran"] = v.(bool)
			}
			if v, ok := d.GetOk("radio_access_technology.0.geran"); ok {
				radioAccessTechnologyPayload["geran"] = v.(bool)
			}
			if v, ok := d.GetOk("radio_access_technology.0.wlan"); ok {
				radioAccessTechnologyPayload["wlan"] = v.(bool)
			}
			if v, ok := d.GetOk("radio_access_technology.0.gan"); ok {
				radioAccessTechnologyPayload["gan"] = v.(bool)
			}
			if v, ok := d.GetOk("radio_access_technology.0.hspa_evolution"); ok {
				radioAccessTechnologyPayload["hspa-evolution"] = v.(bool)
			}
			if v, ok := d.GetOk("radio_access_technology.0.eutran"); ok {
				radioAccessTechnologyPayload["eutran"] = v.(bool)
			}
			if v, ok := d.GetOk("radio_access_technology.0.virtual"); ok {
				radioAccessTechnologyPayload["virtual"] = v.(bool)
			}
			if v, ok := d.GetOk("radio_access_technology.0.nb_iot"); ok {
				radioAccessTechnologyPayload["nb-iot"] = v.(bool)
			}
			if _, ok := d.GetOk("radio_access_technology.0.other_types_range"); ok {

				otherTypesRangePayload := make(map[string]interface{})

				if v, ok := d.GetOk("radio_access_technology.0.other_types_range.0.enable"); ok {
					otherTypesRangePayload["enable"] = strconv.FormatBool(v.(bool))
				}
				if v, ok := d.GetOk("radio_access_technology.0.other_types_range.0.types"); ok {
					otherTypesRangePayload["types"] = v.(string)
				}
				radioAccessTechnologyPayload["other-types-range"] = otherTypesRangePayload
			}
			serviceGtp["radio-access-technology"] = radioAccessTechnologyPayload
		}
	}
	if v, ok := d.GetOkExists("restoration_and_recovery"); ok {
		serviceGtp["restoration-and-recovery"] = v.(bool)
	}

	if v, ok := d.GetOkExists("reverse_service"); ok {
		serviceGtp["reverse-service"] = v.(bool)
	}

	if _, ok := d.GetOk("selection_mode"); ok {

		res := make(map[string]interface{})

		if v, ok := d.GetOk("selection_mode.0.enable"); ok {
			res["enable"] = v
		}
		if v, ok := d.GetOk("selection_mode.0.mode"); ok {
			res["mode"] = v
		}
		serviceGtp["selection-mode"] = res
	}

	if v, ok := d.GetOkExists("trace_management"); ok {
		serviceGtp["trace-management"] = v.(bool)
	}

	if v, ok := d.GetOk("tags"); ok {
		serviceGtp["tags"] = v.(*schema.Set).List()
	}

	if v, ok := d.GetOk("color"); ok {
		serviceGtp["color"] = v.(string)
	}

	if v, ok := d.GetOk("comments"); ok {
		serviceGtp["comments"] = v.(string)
	}

	if v, ok := d.GetOk("groups"); ok {
		serviceGtp["groups"] = v.(*schema.Set).List()
	}

	if v, ok := d.GetOkExists("ignore_warnings"); ok {
		serviceGtp["ignore-warnings"] = v.(bool)
	}

	if v, ok := d.GetOkExists("ignore_errors"); ok {
		serviceGtp["ignore-errors"] = v.(bool)
	}

	log.Println("Create ServiceGtp - Map = ", serviceGtp)

	addServiceGtpRes, err := client.ApiCall("add-service-gtp", serviceGtp, client.GetSessionID(), true, false)
	if err != nil || !addServiceGtpRes.Success {
		if addServiceGtpRes.ErrorMsg != "" {
			return fmt.Errorf(addServiceGtpRes.ErrorMsg)
		}
		return fmt.Errorf(err.Error())
	}

	d.SetId(addServiceGtpRes.GetData()["uid"].(string))

	return readManagementServiceGtp(d, m)
}

func readManagementServiceGtp(d *schema.ResourceData, m interface{}) error {

	client := m.(*checkpoint.ApiClient)

	payload := map[string]interface{}{
		"uid": d.Id(),
	}

	showServiceGtpRes, err := client.ApiCall("show-service-gtp", payload, client.GetSessionID(), true, false)
	if err != nil {
		return fmt.Errorf(err.Error())
	}
	if !showServiceGtpRes.Success {
		if objectNotFound(showServiceGtpRes.GetData()["code"].(string)) {
			d.SetId("")
			return nil
		}
		return fmt.Errorf(showServiceGtpRes.ErrorMsg)
	}

	serviceGtp := showServiceGtpRes.GetData()

	log.Println("Read ServiceGtp - Show JSON = ", serviceGtp)

	if v := serviceGtp["name"]; v != nil {
		_ = d.Set("name", v)
	}

	if v := serviceGtp["version"]; v != nil {
		_ = d.Set("version", v)
	}

	if serviceGtp["access-point-name"] != nil {

		accessPointNameMap := serviceGtp["access-point-name"].(map[string]interface{})

		accessPointNameMapToReturn := make(map[string]interface{})

		if v := accessPointNameMap["enable"]; v != nil {
			accessPointNameMapToReturn["enable"] = v
		}
		if v := accessPointNameMap["apn"]; v != nil {
			accessPointNameMapToReturn["apn"] = v
		}
		_ = d.Set("access_point_name", []interface{}{accessPointNameMapToReturn})

	} else {
		_ = d.Set("access_point_name", nil)
	}

	if v := serviceGtp["allow-usage-of-static-ip"]; v != nil {
		_ = d.Set("allow_usage_of_static_ip", v)
	}

	if serviceGtp["apply-access-policy-on-user-traffic"] != nil {

		applyAccessPolicyOnUserTrafficMap := serviceGtp["apply-access-policy-on-user-traffic"].(map[string]interface{})

		applyAccessPolicyOnUserTrafficMapToReturn := make(map[string]interface{})

		if v := applyAccessPolicyOnUserTrafficMap["enable"]; v != nil {
			applyAccessPolicyOnUserTrafficMapToReturn["enable"] = v
		}
		if v := applyAccessPolicyOnUserTrafficMap["add-imsi-field-to-log"]; v != nil {
			applyAccessPolicyOnUserTrafficMapToReturn["add_imsi_field_to_log"] = v
		}
		_ = d.Set("apply_access_policy_on_user_traffic", []interface{}{applyAccessPolicyOnUserTrafficMapToReturn})

	} else {
		_ = d.Set("apply_access_policy_on_user_traffic", nil)
	}

	if v := serviceGtp["cs-fallback-and-srvcc"]; v != nil {
		_ = d.Set("cs_fallback_and_srvcc", v)
	}

	if serviceGtp["imsi-prefix"] != nil {

		imsiPrefixMap := serviceGtp["imsi-prefix"].(map[string]interface{})

		imsiPrefixMapToReturn := make(map[string]interface{})

		if v := imsiPrefixMap["enable"]; v != nil {
			imsiPrefixMapToReturn["enable"] = v
		}
		if v := imsiPrefixMap["prefix"]; v != nil {
			imsiPrefixMapToReturn["prefix"] = v
		}
		_ = d.Set("imsi_prefix", []interface{}{imsiPrefixMapToReturn})

	} else {
		_ = d.Set("imsi_prefix", nil)
	}

	if serviceGtp["interface-profile"] != nil {

		interfaceProfileMap := serviceGtp["interface-profile"].(map[string]interface{})

		interfaceProfileMapToReturn := make(map[string]interface{})

		if v := interfaceProfileMap["profile"]; v != nil {
			interfaceProfileMapToReturn["profile"] = v
		}
		if v := interfaceProfileMap["custom-message-types"]; v != nil {
			interfaceProfileMapToReturn["custom_message_types"] = v
		}
		_ = d.Set("interface_profile", []interface{}{interfaceProfileMapToReturn})

	} else {
		_ = d.Set("interface_profile", nil)
	}

	if serviceGtp["ldap-group"] != nil {

		ldapGroupMap := serviceGtp["ldap-group"].(map[string]interface{})

		ldapGroupMapToReturn := make(map[string]interface{})

		if v := ldapGroupMap["enable"]; v != nil {
			ldapGroupMapToReturn["enable"] = v
		}
		if v := ldapGroupMap["group"]; v != nil {
			ldapGroupMapToReturn["group"] = v
		}
		if v := ldapGroupMap["according-to"]; v != nil {
			ldapGroupMapToReturn["according_to"] = v
		}
		_ = d.Set("ldap_group", []interface{}{ldapGroupMapToReturn})

	} else {
		_ = d.Set("ldap_group", nil)
	}

	if serviceGtp["ms-isdn"] != nil {

		msIsdnMap := serviceGtp["ms-isdn"].(map[string]interface{})

		msIsdnMapToReturn := make(map[string]interface{})

		if v := msIsdnMap["enable"]; v != nil {
			msIsdnMapToReturn["enable"] = v
		}
		if v := msIsdnMap["ms-isdn"]; v != nil {
			msIsdnMapToReturn["ms_isdn"] = v
		}
		_ = d.Set("ms_isdn", []interface{}{msIsdnMapToReturn})

	} else {
		_ = d.Set("ms_isdn", nil)
	}

	if serviceGtp["radio-access-technology"] != nil {

		radioAccessTechnologyMap, ok := serviceGtp["radio-access-technology"].(map[string]interface{})

		if ok {
			radioAccessTechnologyMapToReturn := make(map[string]interface{})

			if v := radioAccessTechnologyMap["utran"]; v != nil {
				radioAccessTechnologyMapToReturn["utran"] = v
			}
			if v := radioAccessTechnologyMap["geran"]; v != nil {
				radioAccessTechnologyMapToReturn["geran"] = v
			}
			if v := radioAccessTechnologyMap["wlan"]; v != nil {
				radioAccessTechnologyMapToReturn["wlan"] = v
			}
			if v := radioAccessTechnologyMap["gan"]; v != nil {
				radioAccessTechnologyMapToReturn["gan"] = v
			}
			if v := radioAccessTechnologyMap["hspa-evolution"]; v != nil {
				radioAccessTechnologyMapToReturn["hspa_evolution"] = v
			}
			if v := radioAccessTechnologyMap["eutran"]; v != nil {
				radioAccessTechnologyMapToReturn["eutran"] = v
			}
			if v := radioAccessTechnologyMap["virtual"]; v != nil {
				radioAccessTechnologyMapToReturn["virtual"] = v
			}
			if v := radioAccessTechnologyMap["nb-iot"]; v != nil {
				radioAccessTechnologyMapToReturn["nb_iot"] = v
			}
			if v, ok := radioAccessTechnologyMap["other-types-range"]; ok {

				otherTypesRangeMap, ok := v.(map[string]interface{})
				if ok {
					otherTypesRangeMapToReturn := make(map[string]interface{})

					if v, _ := otherTypesRangeMap["enable"]; v != nil {
						otherTypesRangeMapToReturn["enable"] = v
					}
					if v, _ := otherTypesRangeMap["types"]; v != nil {
						otherTypesRangeMapToReturn["types"] = v
					}
					radioAccessTechnologyMapToReturn["other_types_range"] = []interface{}{otherTypesRangeMapToReturn}
				}
			}
			_ = d.Set("radio_access_technology", []interface{}{radioAccessTechnologyMapToReturn})

		}
	} else {
		_ = d.Set("radio_access_technology", nil)
	}

	if v := serviceGtp["restoration-and-recovery"]; v != nil {
		_ = d.Set("restoration_and_recovery", v)
	}

	if v := serviceGtp["reverse-service"]; v != nil {
		_ = d.Set("reverse_service", v)
	}

	if serviceGtp["selection-mode"] != nil {

		selectionModeMapToReturn := make(map[string]interface{})

		innerMap := serviceGtp["selection-mode"].(map[string]interface{})

		if v, _ := innerMap["mode"]; v != nil {

			selectionModeMapToReturn["mode"] = v
		}

		if v, _ := innerMap["enable"]; v != nil {
			selectionModeMapToReturn["enable"] = v
		}

		_ = d.Set("selection_mode", []interface{}{selectionModeMapToReturn})
	} else {
		_ = d.Set("selection_mode", nil)
	}

	if v := serviceGtp["trace-management"]; v != nil {
		_ = d.Set("trace_management", v)
	}

	if serviceGtp["tags"] != nil {
		tagsJson, ok := serviceGtp["tags"].([]interface{})
		if ok {
			tagsIds := make([]string, 0)
			if len(tagsJson) > 0 {
				for _, tags := range tagsJson {
					tags := tags.(map[string]interface{})
					tagsIds = append(tagsIds, tags["name"].(string))
				}
			}
			_ = d.Set("tags", tagsIds)
		}
	} else {
		_ = d.Set("tags", nil)
	}

	if v := serviceGtp["color"]; v != nil {
		_ = d.Set("color", v)
	}

	if v := serviceGtp["comments"]; v != nil {
		_ = d.Set("comments", v)
	}

	if serviceGtp["groups"] != nil {
		groupsJson, ok := serviceGtp["groups"].([]interface{})
		if ok {
			groupsIds := make([]string, 0)
			if len(groupsJson) > 0 {
				for _, groups := range groupsJson {
					groups := groups.(map[string]interface{})
					groupsIds = append(groupsIds, groups["name"].(string))
				}
			}
			_ = d.Set("groups", groupsIds)
		}
	} else {
		_ = d.Set("groups", nil)
	}

	if v := serviceGtp["ignore-warnings"]; v != nil {
		_ = d.Set("ignore_warnings", v)
	}

	return nil

}

func updateManagementServiceGtp(d *schema.ResourceData, m interface{}) error {

	client := m.(*checkpoint.ApiClient)
	serviceGtp := make(map[string]interface{})

	if ok := d.HasChange("name"); ok {
		oldName, newName := d.GetChange("name")
		serviceGtp["name"] = oldName
		serviceGtp["new-name"] = newName
	} else {
		serviceGtp["name"] = d.Get("name")
	}

	if ok := d.HasChange("version"); ok {
		serviceGtp["version"] = d.Get("version")
	}

	if d.HasChange("access_point_name") {

		if v, ok := d.GetOk("access_point_name"); ok {

			accessPointNameList := v.([]interface{})

			if len(accessPointNameList) > 0 {

				accessPointNamePayload := make(map[string]interface{})

				if v, ok := d.GetOkExists("access_point_name.0.enable"); ok {
					accessPointNamePayload["enable"] = v.(bool)
				}
				if v, ok := d.GetOk("access_point_name.0.apn"); ok {
					accessPointNamePayload["apn"] = v.(string)
				}
				serviceGtp["access-point-name"] = accessPointNamePayload
			}
		}
	}
	if v, ok := d.GetOkExists("allow_usage_of_static_ip"); ok {
		serviceGtp["allow-usage-of-static-ip"] = v.(bool)
	}
	if d.HasChange("apply_access_policy_on_user_traffic") {

		if v, ok := d.GetOk("apply_access_policy_on_user_traffic"); ok {

			applyAccessPolicyOnUserTrafficList := v.([]interface{})

			if len(applyAccessPolicyOnUserTrafficList) > 0 {

				applyAccessPolicyOnUserTrafficPayload := make(map[string]interface{})

				if v, ok := d.GetOkExists("apply_access_policy_on_user_traffic.0.enable"); ok {
					applyAccessPolicyOnUserTrafficPayload["enable"] = v.(bool)
				}
				if v, ok := d.GetOkExists("apply_access_policy_on_user_traffic.0.add_imsi_field_to_log"); ok {
					applyAccessPolicyOnUserTrafficPayload["add-imsi-field-to-log"] = v.(bool)
				}
				serviceGtp["apply-access-policy-on-user-traffic"] = applyAccessPolicyOnUserTrafficPayload
			}
		}
	}
	if v, ok := d.GetOkExists("cs_fallback_and_srvcc"); ok {
		serviceGtp["cs-fallback-and-srvcc"] = v.(bool)
	}
	if d.HasChange("imsi_prefix") {

		if v, ok := d.GetOk("imsi_prefix"); ok {

			imsiPrefixList := v.([]interface{})

			if len(imsiPrefixList) > 0 {

				imsiPrefixPayload := make(map[string]interface{})

				if v, ok := d.GetOkExists("imsi_prefix.0.enable"); ok {
					imsiPrefixPayload["enable"] = v.(bool)
				}
				if v, ok := d.GetOk("imsi_prefix.0.prefix"); ok {
					imsiPrefixPayload["prefix"] = v.(string)
				}
				serviceGtp["imsi-prefix"] = imsiPrefixPayload
			}
		}
	}
	if d.HasChange("interface_profile") {

		if v, ok := d.GetOk("interface_profile"); ok {

			interfaceProfileList := v.([]interface{})

			if len(interfaceProfileList) > 0 {

				interfaceProfilePayload := make(map[string]interface{})

				if v, ok := d.GetOk("interface_profile.0.profile"); ok {
					interfaceProfilePayload["profile"] = v.(string)
				}
				if v, ok := d.GetOk("interface_profile.0.custom_message_types"); ok {
					interfaceProfilePayload["custom-message-types"] = v.(string)
				}
				serviceGtp["interface-profile"] = interfaceProfilePayload
			}
		}
	}
	if d.HasChange("ldap_group") {

		if v, ok := d.GetOk("ldap_group"); ok {

			ldapGroupList := v.([]interface{})

			if len(ldapGroupList) > 0 {

				ldapGroupPayload := make(map[string]interface{})

				if v, ok := d.GetOkExists("ldap_group.0.enable"); ok {
					ldapGroupPayload["enable"] = v.(bool)
				}
				if v, ok := d.GetOk("ldap_group.0.group"); ok {
					ldapGroupPayload["group"] = v.(string)
				}
				if v, ok := d.GetOk("ldap_group.0.according_to"); ok {
					ldapGroupPayload["according-to"] = v.(string)
				}
				serviceGtp["ldap-group"] = ldapGroupPayload
			}
		}
	}
	if d.HasChange("ms_isdn") {

		if v, ok := d.GetOk("ms_isdn"); ok {

			msIsdnList := v.([]interface{})

			if len(msIsdnList) > 0 {

				msIsdnPayload := make(map[string]interface{})

				if v, ok := d.GetOkExists("ms_isdn.0.enable"); ok {
					msIsdnPayload["enable"] = v.(bool)
				}
				if v, ok := d.GetOk("ms_isdn.0.ms_isdn"); ok {
					msIsdnPayload["ms-isdn"] = v.(string)
				}
				serviceGtp["ms-isdn"] = msIsdnPayload
			}
		}
	}
	if d.HasChange("radio_access_technology") {
		if v, ok := d.GetOk("radio_access_technology"); ok {
			radioAccessTechnologyList := v.([]interface{})

			if len(radioAccessTechnologyList) > 0 {
				radioAccessTechnologyPayload := make(map[string]interface{})
				if v, ok := d.GetOk("radio_access_technology.0.utran"); ok {
					radioAccessTechnologyPayload["utran"] = v.(bool)
				}
				if v, ok := d.GetOk("radio_access_technology.0.geran"); ok {
					radioAccessTechnologyPayload["geran"] = v.(bool)
				}
				if v, ok := d.GetOk("radio_access_technology.0.wlan"); ok {
					radioAccessTechnologyPayload["wlan"] = v.(bool)
				}
				if v, ok := d.GetOk("radio_access_technology.0.gan"); ok {
					radioAccessTechnologyPayload["gan"] = v.(bool)
				}
				if v, ok := d.GetOk("radio_access_technology.0.hspa_evolution"); ok {
					radioAccessTechnologyPayload["hspa-evolution"] = v.(bool)
				}
				if v, ok := d.GetOk("radio_access_technology.0.eutran"); ok {
					radioAccessTechnologyPayload["eutran"] = v.(bool)
				}
				if v, ok := d.GetOk("radio_access_technology.0.virtual"); ok {
					radioAccessTechnologyPayload["virtual"] = v.(bool)
				}
				if v, ok := d.GetOk("radio_access_technology.0.nb_iot"); ok {
					radioAccessTechnologyPayload["nb-iot"] = v.(bool)
				}
				if _, ok := d.GetOk("radio_access_technology.0.other_types_range"); ok {
					otherTypesRangePayload := make(map[string]interface{})
					if v, ok := d.GetOk("radio_access_technology.0.other_types_range.0.enable"); ok {
						otherTypesRangePayload["enable"] = v
					}
					if v, ok := d.GetOk("radio_access_technology.0.other_types_range.0.types"); ok {
						otherTypesRangePayload["types"] = v.(string)
					}
					radioAccessTechnologyPayload["other-types-range"] = otherTypesRangePayload
				}
				serviceGtp["radio-access-technology"] = radioAccessTechnologyPayload
			}
		}
	}
	if v, ok := d.GetOkExists("restoration_and_recovery"); ok {
		serviceGtp["restoration-and-recovery"] = v.(bool)
	}
	if v, ok := d.GetOkExists("reverse_service"); ok {
		serviceGtp["reverse-service"] = v.(bool)
	}
	if d.HasChange("selection_mode") {
		if _, ok := d.GetOk("selection_mode"); ok {
			res := make(map[string]interface{})
			if v, ok := d.GetOk("selection_mode.0.enable"); ok {
				res["enable"] = v
			}
			if v, ok := d.GetOk("selection_mode.0.mode"); ok {
				res["mode"] = v
			}
			serviceGtp["selection-mode"] = res
		}
	}
	if v, ok := d.GetOkExists("trace_management"); ok {
		serviceGtp["trace-management"] = v.(bool)
	}
	if d.HasChange("tags") {
		if v, ok := d.GetOk("tags"); ok {
			serviceGtp["tags"] = v.(*schema.Set).List()
		} else {
			oldTags, _ := d.GetChange("tags")
			serviceGtp["tags"] = map[string]interface{}{"remove": oldTags.(*schema.Set).List()}
		}
	}
	if ok := d.HasChange("color"); ok {
		serviceGtp["color"] = d.Get("color")
	}
	if ok := d.HasChange("comments"); ok {
		serviceGtp["comments"] = d.Get("comments")
	}
	if d.HasChange("groups") {
		if v, ok := d.GetOk("groups"); ok {
			serviceGtp["groups"] = v.(*schema.Set).List()
		} else {
			oldGroups, _ := d.GetChange("groups")
			serviceGtp["groups"] = map[string]interface{}{"remove": oldGroups.(*schema.Set).List()}
		}
	}
	if v, ok := d.GetOkExists("ignore_warnings"); ok {
		serviceGtp["ignore-warnings"] = v.(bool)
	}
	if v, ok := d.GetOkExists("ignore_errors"); ok {
		serviceGtp["ignore-errors"] = v.(bool)
	}

	log.Println("Update ServiceGtp - Map = ", serviceGtp)

	updateServiceGtpRes, err := client.ApiCall("set-service-gtp", serviceGtp, client.GetSessionID(), true, false)
	if err != nil || !updateServiceGtpRes.Success {
		if updateServiceGtpRes.ErrorMsg != "" {
			return fmt.Errorf(updateServiceGtpRes.ErrorMsg)
		}
		return fmt.Errorf(err.Error())
	}

	return readManagementServiceGtp(d, m)
}

func deleteManagementServiceGtp(d *schema.ResourceData, m interface{}) error {

	client := m.(*checkpoint.ApiClient)

	serviceGtpPayload := map[string]interface{}{
		"uid": d.Id(),
	}
	if v, ok := d.GetOkExists("ignore_warnings"); ok {
		serviceGtpPayload["ignore-warnings"] = v.(bool)
	}

	if v, ok := d.GetOkExists("ignore_errors"); ok {
		serviceGtpPayload["ignore-errors"] = v.(bool)
	}
	log.Println("Delete ServiceGtp")

	deleteServiceGtpRes, err := client.ApiCall("delete-service-gtp", serviceGtpPayload, client.GetSessionID(), true, false)
	if err != nil || !deleteServiceGtpRes.Success {
		if deleteServiceGtpRes.ErrorMsg != "" {
			return fmt.Errorf(deleteServiceGtpRes.ErrorMsg)
		}
		return fmt.Errorf(err.Error())
	}
	d.SetId("")

	return nil
}
